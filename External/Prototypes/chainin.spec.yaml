
chaining:
  - relation: successor/predecessor/implemented/implements/enabled/enables/synergize
    vector: 
    description:
  
  - relation: hierarchy::implemented
    vector:
    description:
sequence::successor
sequence::predecessor
atomicity::implements
atomicity::implemented
support::enabled
support::enables
support::synergize

  #deliver:
  #  - software:
  #    relation: delivered
  #    description:
  #perform:
  #  - software:
  #    relation: performed
  #    description:

# Requirement
#
# - Support bi-directions (can also NOT depending on type)
# - Lateral modeling
# - Can be extended elegantly with new keyword
# - Easy to understand the type of relatioships

# Structure
# chaining:
#   relationship_category:
#      - vector:
#        #software
#        relation: <subrelation categories>
#        description:
#

# OSM - Need further research if needs chaining. Same chaning types, different
# Do we want chaining on both end for OSM -- If yes may be complex ?
# OR OSM should be consumed by TVMs only, similar to TAM. --> Simplifies development greatly.
#    ^ This option is probably the one most in scope. Chaining is better to remain a TVM only behaviour.
#      However, the display of a vector chain should be enriched with threat actors and OSM. 
#
# May need common vocabulary -- may need extension to json schema builder to know how to combine vocabs
# Or key shown as optional to show that relations may be done -- better if we want to segment off certain types
# Not super elegant to comment out key...
#
# vector vocab, software vocab, threat vocab or hidden keys (would hide both in that case)
#
# Keywords of interest
#
# Delivery
# Execution
# OSM may enable TVM
# OSM may implement a TVM - same as execution ? Implement for TVM only
# OSM may be sequenced with a TVM