import pandas as pd
import os
import git
from pathlib import Path
import sys
import shutil
import time

sys.path.append(str(git.Repo(".", search_parent_directories=True).working_dir))

from Engines.modules.framework import (
    get_value_metaschema,
    get_type,
    techniques_resolver,
)
from Engines.modules.documentation import (
    get_field_title,
    get_icon,
    rich_attack_links,
    get_vocab_description,
    model_value_doc,
    FOLD,
)
from Engines.modules.files import safe_file_name
from Engines.templates.mdr import TEMPLATEv3
from Engines.modules.documentation_components import (
    tlp_doc,
    metadata_doc,
    relations_table,
)
from Engines.modules.tide import DataTide
from Engines.modules.logs import log
from Engines.modules.deployment import enabled_systems

ROOT = Path(str(git.Repo(".", search_parent_directories=True).working_dir))

DOCUMENTATION_TYPE = DataTide.Configurations.Documentation.documentation_type
DEFAULT_RESPONDERS = DataTide.Configurations.Deployment.default_responders
SYSTEMS_CONFIG = DataTide.Configurations.Systems.Index
VOCAB_INDEX = DataTide.Vocabularies.Index
MODELS_INDEX = DataTide.Models.Index
MDR_ICON = get_icon("mdr")

QUERY_FOLD = """
<details>
<summary>{}</summary>

```sql
{}
```

</details>
&nbsp; 
"""

# Fetch metaschema
MDR_METASCHEMA = DataTide.TideSchemas.mdr["properties"]


WIKI = ROOT / Path(DataTide.Configurations.Documentation.models_docs_folder)
MDR_WIKI_PATH = WIKI / DataTide.Configurations.Documentation.object_names["mdr"]

MARKDOWN = False
GLFM = False

# Fetch relevant subschemas
# Since we mutate SYSTEMS_SUBSCHEMA, creates conflict with other Engines.modules. hence the copy()
SYSTEMS_SUBSCHEMAS = DataTide.TideSchemas.subschemas["systems"].copy()
for sub in SYSTEMS_SUBSCHEMAS.copy():
    new_data = SYSTEMS_SUBSCHEMAS[sub]["properties"]
    SYSTEMS_SUBSCHEMAS.pop(sub)
    SYSTEMS_SUBSCHEMAS[sub] = new_data


if DOCUMENTATION_TYPE == "MARKDOWN":
    MARKDOWN = True
elif DOCUMENTATION_TYPE == "GLFM":
    GLFM = True

if GLFM:
    MDR_WIKI_PATH = Path(str(MDR_WIKI_PATH).replace(" ", "-"))
    print("ü¶ä Configured to use Gitlab Flavored Markdown")


start_time = time.time()


def documentation(mdr):

    doc = str()
    mdr_configs = mdr["configurations"]

    frontmatter_type = DataTide.Configurations.Documentation.object_names["mdr"]
    frontmatter = f"---\ntype: {frontmatter_type}\n---"
    if GLFM:
        frontmatter = ""

    name = mdr["name"]

    if MARKDOWN:
        name = f"# {MDR_ICON} {name}"

    uuid_data = mdr["uuid"]
    uuid = f"{get_icon('uuid')} **UUID** : `{uuid_data}`"
    description = mdr.get("description", "").replace("\n", "\n> ")

    techniques = techniques_resolver(uuid_data)
    if techniques:
        techniques = rich_attack_links(techniques, output="string")
        techniques = f"{get_icon('att&ck')} **ATT&CK Techniques** :  {techniques}"
    else:
        techniques = ""

    cdm = relations_table(uuid_data, "upstream")

    # Get Severity Data
    severity_data = mdr["response"]["alert_severity"]
    severity_col = get_field_title("alert_severity", MDR_METASCHEMA)
    severity_description = get_vocab_description("alert_severity", severity_data)
    severity_data = f"**{severity_data}** : {severity_description}"

    # Get Alert responder data
    responders_data = mdr.get("response", {}).get("responders") or DEFAULT_RESPONDERS
    responders_col = get_field_title("responders", MDR_METASCHEMA)
    if responders_data == "":
        responders_data = "**No defined responders for alerts generated by this MDR**"
    else:
        responders_description = get_vocab_description("responders", responders_data)
        responders_data = f"**{responders_data}** : {responders_description}"

    # Get playbook data
    playbook_data = mdr.get("response", {}).get("playbook")
    playbook_col = get_field_title("playbook", MDR_METASCHEMA)
    if not playbook_data:
        playbook_data = "No playbook was defined for this detection rule"
        if GLFM:
            playbook_data = f"[-{playbook_data}-]"
    else:
        playbook_name = playbook_data.split("/")[-1]
        playbook_name = playbook_name.replace("+", " ")
        playbook_name = playbook_name.replace("_", " ")
        playbook_data = f"[{playbook_name}]({playbook_data})"

    # Create Response Data Table
    response = pd.DataFrame(columns=[severity_col, responders_col, playbook_col])
    response.loc[0] = [severity_data, responders_data, playbook_data]
    response = response.to_markdown(index=False)

    # Make Banner if staging rule
    if "TIDE_MDR_STAGING_BANNER" in globals():
        banner = globals()["TIDE_MDR_STAGING_BANNER"].get(uuid_data) or ""
        if banner:
            if GLFM:
                banner = f"‚ö†Ô∏è [-{banner.replace('‚ö†Ô∏è', '')}-]"
    else:
        banner = ""

    # Make References
    references = mdr.get("references") or ""
    if references != "":
        references = "- " + "\n- ".join(references)
    else:
        references = "_No references mentioned_"

    # Add enriched configuration data
    configurations = str()

    for s in mdr_configs:
        config_data = list()
        status_name = mdr_configs[s]["status"]
        status_name = f"{get_icon(status_name, 'status')} {status_name}"
        system_name = SYSTEMS_CONFIG[s]["tide"]["name"] + f" <b>{status_name}</b>"
        system_data = pd.json_normalize(mdr_configs[s], sep="|").to_dict(
            orient="records"
        )[0]
        system_data.pop("query")

        for key in system_data.copy():  # Avoids dict mutation errors
            buffer = dict()

            cleaned_key = str(key).split("|")[
                -1
            ]  # Keep only the string after the last separator
            # system_data[new_key] = system_data.pop(key)
            key_name = get_field_title(cleaned_key, SYSTEMS_SUBSCHEMAS[s])
            param_description = get_value_metaschema(
                cleaned_key, metaschema=SYSTEMS_SUBSCHEMAS[s], retrieve="description"
            )
            param_name = get_value_metaschema(
                cleaned_key,
                metaschema=SYSTEMS_SUBSCHEMAS[s],
                retrieve="tide.mdr.parameter",
            )
            data = system_data[key]

            # If vocab entry, will fetch data to enrich
            if cleaned_key in VOCAB_INDEX:
                if cleaned_key == "status":
                    enriched_value = status_name
                else:
                    enriched_value = model_value_doc(
                        uuid_data, cleaned_key, with_icon=True
                    )
                data = (
                    f"**{enriched_value}** : {get_vocab_description(cleaned_key, data)}"
                )

            # TODO Better Sentinel Entities Handling
            # TODO Pretty print dictionaries in general
            # Convert list to joined string

            if type(data) is list:
                if type(data[0]) is not dict:
                    data = ", ".join(data)
                else:
                    data = data[0]

            # Prevents from being rendered with mathematical expression formatting
            if type(data) is str:
                data = data.replace("$", r"\$")
                data = data.replace("\n", "")

            if type(data) is dict:
                data = str(data)

            buffer["Parameter"] = key_name
            buffer["System Config"] = param_name
            buffer["Description"] = param_description
            buffer["Config"] = data

            config_data.append(buffer)

        table = pd.DataFrame(config_data).to_markdown(index=False)

        if s not in enabled_systems():
            system_name += "[DISABLED]"
            banner = "This system is not enabled in your System Configurations, "\
                "this documentation is only informational"
            if GLFM:
                banner = f"[- {banner} -]"
            table = banner + "\n\n" + table
                
        fold = FOLD.format(system_name, table)

        configurations += fold

    # Add Query Folds
    queries = str()
    query_data = dict()
    for s in mdr_configs:
        query = mdr_configs[s].get("query").strip()
        expander = f"Expand to view {SYSTEMS_CONFIG[s]['tide']['name']} query"
        queries += QUERY_FOLD.format(expander, query)

    # Make metadata footer
    mdr_metadata = mdr.get("metadata") or mdr["meta"]

    # Make TLP
    tlp = tlp_doc(mdr_metadata["tlp"])

    metadata = {k: v for k, v in mdr_metadata.items() if k != "tlp"}
    metadata = metadata_doc(metadata, model_type="tvm")

    doc = TEMPLATEv3.format(
        frontmatter=frontmatter,
        name=name,
        banner=banner,
        tlp=tlp,
        techniques=techniques,
        uuid=uuid_data,
        metadata=metadata,
        description=description,
        cdm=cdm,
        response=response,
        configurations=configurations,
        queries=queries,
        references=references,
    )

    return doc


def run():

    log("TITLE", "MDR Documentation")
    log("INFO", "Generates markdown documentation for Managed Detection Rules v3.")

    # Remove all previous docs
    if os.path.exists(MDR_WIKI_PATH):
        shutil.rmtree(MDR_WIKI_PATH)
    MDR_WIKI_PATH.mkdir(parents=True)

    # Initialize a counter of created documents
    mdr_doc_count = 0

    for mdr_uuid in MODELS_INDEX["mdr"]:
        if get_type(mdr_uuid, get_version=True) == "mdrv3":

            # Make a file name based on MDR data
            mdr_data = MODELS_INDEX["mdr"][mdr_uuid]
            doc_name = mdr_data.get("name").replace("_", " ")
            doc_file_name = f"{MDR_ICON} {doc_name}.md"
            doc_file_name = safe_file_name(doc_file_name)
            doc_path = MDR_WIKI_PATH / doc_file_name
            print(f"{MDR_ICON} Generating documentation for {doc_name}...")

            document = documentation(mdr_data)

            # Replace whitespace in file name as it becomes a path in the Gitlab Wiki
            if DOCUMENTATION_TYPE == "GLFM":
                doc_path = Path(str(doc_path).replace(" ", "-"))

            with open(doc_path, "w+", encoding="utf-8") as output:
                output.write(document)
                mdr_doc_count += 1


if __name__ == "__main__":
    run()
