import pandas as pd
import os
import git
from pathlib import Path
import sys
import shutil
import time

sys.path.append(str(git.Repo(".", search_parent_directories=True).working_dir))

from Engines.modules.framework import (
    get_value_metaschema,
    techniques_resolver,
)
from Engines.modules.documentation import (
    get_field_title,
    get_icon,
    rich_attack_links,
    get_vocab_description,
    model_value_doc,
    FOLD,
)
from Engines.modules.files import safe_file_name
from Engines.templates.mdr import TEMPLATEv3
from Engines.modules.documentation_components import (
    tlp_doc,
    metadata_doc,
    relations_table,
    reference_doc
)
from Engines.modules.tide import DataTide
from Engines.modules.logs import log
from Engines.modules.deployment import enabled_systems

ROOT = Path(str(git.Repo(".", search_parent_directories=True).working_dir))

DOCUMENTATION_TARGET = DataTide.Configurations.Documentation.documentation_target
if DOCUMENTATION_TARGET == "gitlab":
    UUID_PERMALINKS = DataTide.Configurations.Documentation.gitlab.get("uuid_permalinks", False)
else:
    UUID_PERMALINKS = False

DEFAULT_RESPONDERS = DataTide.Configurations.Deployment.default_responders
SYSTEMS_CONFIG = DataTide.Configurations.Systems.Index
VOCAB_INDEX = DataTide.Vocabularies.Index
MODELS_INDEX = DataTide.Models.Index
MDR_ICON = get_icon("mdr")

QUERY_FOLD = """
<details>
<summary>{}</summary>

```sql
{}
```

</details>
&nbsp; 
"""

# Fetch metaschema
MDR_METASCHEMA = DataTide.TideSchemas.mdr["properties"]


WIKI = Path(DataTide.Configurations.Global.Paths.Core.models_docs_folder)
MDR_WIKI_PATH = WIKI / DataTide.Configurations.Documentation.object_names["mdr"]


# Fetch relevant subschemas
# Since we mutate SYSTEMS_SUBSCHEMA, creates conflict with other Engines.modules. hence the copy()
SYSTEMS_SUBSCHEMAS = DataTide.TideSchemas.subschemas["systems"].copy()
for sub in SYSTEMS_SUBSCHEMAS.copy():
    new_data = SYSTEMS_SUBSCHEMAS[sub]["properties"]
    SYSTEMS_SUBSCHEMAS.pop(sub)
    SYSTEMS_SUBSCHEMAS[sub] = new_data



if DOCUMENTATION_TARGET == "gitlab":
    MDR_WIKI_PATH = Path(str(MDR_WIKI_PATH).replace(" ", "-"))
    print("ðŸ¦Š Configured to use Gitlab Flavored Markdown")

start_time = time.time()

def documentation(mdr):

    doc = str()
    mdr_configs = mdr["configurations"]

    name = f"{MDR_ICON} {mdr['name']}"
    frontmatter = ""

    if DOCUMENTATION_TARGET == "generic":
        name = "# " + name

    if DOCUMENTATION_TARGET == "gitlab":
        if UUID_PERMALINKS:
            frontmatter = f"---\ntitle: {name}\n---"
        name = ""    

    # TODO Backwards compatible with OpenTIDE 1.0, to deprecate at some point
    uuid_data = mdr.get("uuid") or mdr["metadata"]["uuid"]
    description = mdr.get("description", "").replace("\n", "\n> ")

    techniques = techniques_resolver(uuid_data)
    if techniques:
        techniques = rich_attack_links(techniques, output="string")
        techniques = f"{get_icon('att&ck')} **ATT&CK Techniques** :  {techniques}"
    else:
        techniques = ""

    cdm = relations_table(uuid_data, "upstream")

    # Get Severity Data
    severity_data = mdr["response"]["alert_severity"]
    severity_col = get_field_title("alert_severity", MDR_METASCHEMA)
    severity_description = get_vocab_description("alert_severity", severity_data)
    severity_data = f"**{severity_data}** : {severity_description}"

    # Get Alert responder data
    responders_data = mdr.get("response", {}).get("responders") or DEFAULT_RESPONDERS
    responders_col = get_field_title("responders", MDR_METASCHEMA)
    if responders_data == "":
        responders_data = "**No defined responders for alerts generated by this MDR**"
    else:
        responders_description = get_vocab_description("responders", responders_data)
        responders_data = f"**{responders_data}** : {responders_description}"

    # Get playbook data
    playbook_data = mdr.get("response", {}).get("playbook")
    playbook_col = get_field_title("playbook", MDR_METASCHEMA)
    if not playbook_data:
        playbook_data = "No playbook was defined for this detection rule"
        if DOCUMENTATION_TARGET == "gitlab":
            playbook_data = f"[-{playbook_data}-]"
    else:
        playbook_name = playbook_data.split("/")[-1]
        playbook_name = playbook_name.replace("+", " ")
        playbook_name = playbook_name.replace("_", " ")
        playbook_data = f"[{playbook_name}]({playbook_data})"

    # Create Response Data Table
    response = pd.DataFrame(columns=[severity_col, responders_col, playbook_col])
    response.loc[0] = [severity_data, responders_data, playbook_data]
    response = response.to_markdown(index=False)

    references = mdr.get("references")
    # To deprecate once everything is migrated to new reference system
    if type(references) is list:
        references = "- " + "\n- ".join(references)
    elif type(references) is dict:
        references = reference_doc(mdr.get("references"))
    if references:
        references = "### ðŸ”— References\n\n" + references

    # Add enriched configuration data
    configurations = str()

    for s in mdr_configs:
        config_data = list()
        status_name = mdr_configs[s]["status"]
        status_name = f"{get_icon(status_name, 'status')} {status_name}"
        system_name = SYSTEMS_CONFIG[s]["tide"]["name"] + f" <b>{status_name}</b>"
        system_data = pd.json_normalize(mdr_configs[s], sep="|").to_dict(
            orient="records"
        )[0]
        system_data.pop("query")

        for key in system_data.copy():  # Avoids dict mutation errors
            buffer = dict()

            cleaned_key = str(key).split("|")[
                -1
            ]  # Keep only the string after the last separator
            # system_data[new_key] = system_data.pop(key)
            key_name = get_field_title(cleaned_key, SYSTEMS_SUBSCHEMAS[s])
            param_description = get_value_metaschema(
                                    cleaned_key,
                                    metaschema=SYSTEMS_SUBSCHEMAS[s],
                                    retrieve="description"
                                ) or ""
            param_name = get_value_metaschema(
                            cleaned_key,
                            metaschema=SYSTEMS_SUBSCHEMAS[s],
                            retrieve="tide.mdr.parameter",
                        )
            
            param_name = f"`{param_name}`" if param_name else ""
            
            data = system_data[key]

            # If vocab entry, will fetch data to enrich
            if cleaned_key in VOCAB_INDEX:
                if cleaned_key == "status":
                    enriched_value = status_name
                else:
                    enriched_value = model_value_doc(
                        uuid_data, cleaned_key, with_icon=True
                    )
                data = (
                    f"**{enriched_value}** : {get_vocab_description(cleaned_key, data)}"
                )

            buffer["Parameter"] = key_name
            buffer["System Config"] = param_name
            buffer["Description"] = str(param_description).replace("$", r"\$").replace("\n", " ")
            buffer["Config"] = str(data).replace("$", r"\$").replace("\n", " ")

            config_data.append(buffer)

        table = pd.DataFrame(config_data).to_markdown(index=False)

        if s not in enabled_systems():
            system_name += "[DISABLED]"
            banner = "This system is not enabled in your System Configurations, "\
                "this documentation is only informational"
            if DOCUMENTATION_TARGET == "gitlab":
                banner = f"[- {banner} -]"
            table = banner + "\n\n" + table
                
        fold = FOLD.format(system_name, table)

        configurations += fold

    # Add Query Folds
    queries = str()
    query_data = dict()
    for s in mdr_configs:
        query = mdr_configs[s].get("query").strip()
        expander = f"Expand to view {SYSTEMS_CONFIG[s]['tide']['name']} query"
        queries += QUERY_FOLD.format(expander, query)

    # Make metadata footer
    mdr_metadata = mdr.get("metadata") or mdr["meta"]

    # Make TLP
    tlp = tlp_doc(mdr_metadata["tlp"])

    metadata = {k: v for k, v in mdr_metadata.items() if k != "tlp"}
    metadata = metadata_doc(metadata, model_type="tvm")

    doc = TEMPLATEv3.format(
        frontmatter=frontmatter,
        name=name,
        tlp=tlp,
        techniques=techniques,
        metadata=metadata,
        description=description,
        cdm=cdm,
        response=response,
        configurations=configurations,
        queries=queries,
        references=references,
    )

    return doc


def run():

    log("TITLE", "MDR Documentation")
    log("INFO", "Generates markdown documentation for Managed Detection Rules v3.")

    # Remove all previous docs
    if os.path.exists(MDR_WIKI_PATH):
        shutil.rmtree(MDR_WIKI_PATH)
    MDR_WIKI_PATH.mkdir(parents=True)

    # Initialize a counter of created documents
    mdr_doc_count = 0

    for mdr_uuid in MODELS_INDEX["mdr"]:
        
        # Make a file name based on MDR data
        mdr_data = MODELS_INDEX["mdr"][mdr_uuid]
        mdr_name = mdr_data.get("name")
        mdr_uuid = mdr_data.get("metadata").get("uuid")
        
        log("ONGOING",
            "Generating MDR Documentation",
            mdr_name,
            mdr_uuid
            )

        if UUID_PERMALINKS:
            doc_file_name = mdr_data.get("metadata").get("uuid")+ ".md"
        else:
            doc_name = mdr_data.get("name").replace("_", " ")
            doc_file_name = f"{MDR_ICON} {doc_name}.md"
            doc_file_name = safe_file_name(doc_file_name)
            
        doc_path = MDR_WIKI_PATH / doc_file_name
        

        document = documentation(mdr_data)

        # Replace whitespace in file name as it becomes a path in the Gitlab Wiki
        if DOCUMENTATION_TARGET == "gitlab":
            doc_path = Path(str(doc_path).replace(" ", "-"))

        with open(doc_path, "w+", encoding="utf-8") as output:
            output.write(document)
            mdr_doc_count += 1


if __name__ == "__main__":
    run()
